Open PicoBlaze Assembler log for program "program.psm"
Generated by opbasm v1.3
  Assembled on 2022-11-09T15:33:15
  PicoBlaze-6 mode

  Last occupied address: 7F2 hex
  Nominal program memory size: 2K (2048)  address(10:0)
  Actual memory size: 2048
  Occupied memory locations: 107
  Memory locations available: 1941
  Scratchpad size: 64


Assembly listing
----------------
000                             ; kcpsm_demo program

                                ;
000                             ;------------------------------------------------------------------------------------------
000                             ; Copyright Â© 2011-2012, Xilinx, Inc.
000                             ; This file contains confidential and proprietary information of Xilinx, Inc. and is
000                             ; protected under U.S. and international copyright and other intellectual property laws.
000                             ;------------------------------------------------------------------------------------------
                                ;
000                             ; Disclaimer:
000                             ; This disclaimer is not a license and does not grant any rights to the materials
000                             ; distributed herewith. Except as otherwise provided in a valid license issued to
000                             ; you by Xilinx, and to the maximum extent permitted by applicable law: (1) THESE
000                             ; MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX HEREBY
000                             ; DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,
000                             ; INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,
000                             ; OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable
000                             ; (whether in contract or tort, including negligence, or under any other theory
000                             ; of liability) for any loss or damage of any kind or nature related to, arising
000                             ; under or in connection with these materials, including for any direct, or any
000                             ; indirect, special, incidental, or consequential loss or damage (including loss
000                             ; of data, profits, goodwill, or any type of loss or damage suffered as a result
000                             ; of any action brought by a third party) even if such damage or loss was
000                             ; reasonably foreseeable or Xilinx had been advised of the possibility of the same.
                                ;
000                             ; CRITICAL APPLICATIONS
000                             ; Xilinx products are not designed or intended to be fail-safe, or for use in any
000                             ; application requiring fail-safe performance, such as life-support or safety
000                             ; devices or systems, Class III medical devices, nuclear facilities, applications
000                             ; related to the deployment of airbags, or any other applications that could lead
000                             ; to death, personal injury, or severe property or environmental damage
000                             ; (individually and collectively, "Critical Applications"). Customer assumes the
000                             ; sole risk and liability of any use of Xilinx products in Critical Applications,
000                             ; subject only to applicable laws and regulations governing limitations on product
000                             ; liability.
                                ;
000                             ; THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
                                ;
000                             ;------------------------------------------------------------------------------------------
                                ;
                                ;
000                             ;             _  ______ ____  ____  __  __  __
000                             ;            | |/ / ___|  _ \/ ___||  \/  |/ /_
000                             ;            | ' / |   | |_) \___ \| |\/| | '_ \
000                             ;            | . \ |___|  __/ ___) | |  | | (_) )
000                             ;            |_|\_\____|_|   |____/|_|  |_|\___/
                                ;
                                ;
000                             ;                PicoBlaze Reference Design.
                                ;
                                ;
000                             ; Routines for General Purpose I2C Communication
                                ;
000                             ; Ken Chapman - Xilinx Ltd
                                ;
000                             ; 9th March 2012 - Initial Version
000                             ; 12th October 2012 - Adjustments to values assigned to constant directives
000                             ; 16th October 2012 - Code optimisation (lowest level signal drive routines)
000                             ; 25th October 2012 - Correct definition of a binary value (functionally identical)
000                             ; 6th November 2012 - Correction to comment only
                                ;
                                ;
000                             ;     NOTE - This is not a standalone PSM file. Include this file in a program that
000                             ;            then calls these routines and works with the values in scratch pad memory.
                                ;
000                             ;                INCLUDE "i2c_routines.psm"
                                ;
                                ;
000                             ;     IMPORTANT - These routines interact with input and output ports which must
000                             ;                 be appropriately defined to drive and read the physical I2C
000                             ;                 signals. Four CONSTANT directives must define values consistent
000                             ;                 with your port definitions and a further CONSTANT must be defined
000                             ;                 that is related to the frequency of the clock being applied to
000                             ;                 KCPSM6 in your design (Please see descriptions below).
                                ;
                                ;

000                             ; input port addresses
000                             CONSTANT uart_status_port, 80
000                             CONSTANT uart_rx_port, 81
000                             CONSTANT btns_port, 40

000                             ; output port addresses
000                             CONSTANT uart_tx_port, 80
000                             CONSTANT uart_reset_port, 1
000                             CONSTANT bcd_0_port, 40
000                             CONSTANT bcd_1_port, 41
000                             CONSTANT bcd_2_port, 42
000                             CONSTANT bcd_3_port, 43

000                             ; btns bit positions
000                             CONSTANT btnU, 00010000'b
000                             CONSTANT btnR, 00001000'b
000                             CONSTANT btnD, 00000100'b
000                             CONSTANT btnL, 00000010'b
000                             CONSTANT btnC, 00000001'b

000                             ; uart status bit positions
000                             CONSTANT uart_rx_data_present, 00001000'b
000                             CONSTANT uart_tx_full, 00000100'b

000                             ; uart buffer
000                             CONSTANT buffer_fill_address, 20

000                             ; names for registers
000                             NAMEREG sc, bcd_0
000                             NAMEREG sd, bcd_1
000                             NAMEREG se, bcd_2
000                             NAMEREG sf, bcd_3
000                             NAMEREG s7, uart

000                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000                             ; setup code ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000                             ADDRESS 000
000                 cold_start: ; reset uart rx and tx
000  2B011                      OUTPUTK 01, uart_reset_port
001                             ; initialize buffer_fill location to 0
001  01800                      LOAD s8, 00
002  2F820                      STORE s8, buffer_fill_address
003                             ; set registers for storing bcd values to a default value
003  01C00                      LOAD bcd_0, 00
004  01D00                      LOAD bcd_1, 00
005  01E00                      LOAD bcd_2, 00
006  01F00                      LOAD bcd_3, 00
007                             ; update the 7 segment display (should show 0000)
007  20038                      CALL update_display
008                             ; enable interrupts
008  28001                      ENABLE interrupt

009                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
009                             ; main loop ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
009                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
009                       loop: ; read a char
009  20016                      CALL uart_read_char
00A                             ; check if there's something in the buffer
00A  0B820                      FETCH s8, buffer_fill_address
00B  1D804                      COMPARE s8, 04
00C  3200E                      JUMP Z, code_received          ; there's nothing in the buffer
00D  22009                      JUMP loop
00E              code_received: ; there is something in the buffer
00E                             ; if we got here we got a new "code" (4 bytes) in the buffer
00E                             ; get the code
00E  0BC00                      FETCH bcd_0, 00
00F  0BD01                      FETCH bcd_1, 01
010  0BE02                      FETCH bcd_2, 02
011  0BF03                      FETCH bcd_3, 03
012                             ; "clear" the buffer
012  01800                      LOAD s8, 00
013  2F820                      STORE s8, buffer_fill_address
014                             ; update the display with the new code
014  20038                      CALL update_display
015  22009                      JUMP loop

016                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
016                             ; subroutines ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
016                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

016                             ; read a single character from the uart (with timeout) and put it in RAM
016                             ; registers used: s0, s8, uart
016  01000      uart_read_char: LOAD s0, 00
017  13001      urc_no_timeout: ADDCY s0, 01
018  3A021                      JUMP C, urc_end
019  09780                      INPUT uart, uart_status_port
01A  0D708                      TEST uart, uart_rx_data_present
01B  32017                      JUMP Z, urc_no_timeout
01C  09781                      INPUT uart, uart_rx_port
01D  0B820                      FETCH s8, buffer_fill_address
01E  2E780                      STORE uart, (s8)
01F  11801                      ADD s8, 01
020  2F820                      STORE s8, buffer_fill_address
021  25000             urc_end: RETURN


022                             ; Software delay of 1 second
                                ;
022                             ; KCPSM reference designe is fitted with a 50MHz clock.
022                             ; 1 second is 50,000,000 clock cycles.
022                             ; KCPSM6 will execute 25,000,000 instructions.
                                ;
022                             ; The delay loop below decrements the 24-bit value held
022                             ; in registers [s2,s1,s0] until it reaches zero and this
022                             ; loop consists of 4 instructions.
                                ;
022                             ; Therefore the loop needs to count 6,250,000 times so
022                             ; the start value is 5F5E10 hex.
                                ;
022  0125F            delay_1s: LOAD s2, 5F
023  0115E                      LOAD s1, 5E
024  01010                      LOAD s0, 10
025  19001          delay_loop: SUB s0, 1'd
026  1B100                      SUBCY s1, 0'd
027  1B200                      SUBCY s2, 0'd
028  36025                      JUMP NZ, delay_loop
029  25000                      RETURN

02A                             ; write the contents of s5 to the uart
02A                             ; registers uses: s0 and s5
02A  09080     uart_write_byte: INPUT s0, uart_status_port     ; Check if buffer is full
02B  0D004                      TEST s0, uart_tx_full
02C  3602A                      JUMP NZ, uart_write_byte       ; wait if full
02D  2D580                      OUTPUT s5, uart_tx_port
02E  25000                      RETURN

02F  005C0       transmit_code: LOAD s5, bcd_0
030  2002A                      CALL uart_write_byte
031  005D0                      LOAD s5, bcd_1
032  2002A                      CALL uart_write_byte
033  005E0                      LOAD s5, bcd_2
034  2002A                      CALL uart_write_byte
035  005F0                      LOAD s5, bcd_3
036  2002A                      CALL uart_write_byte
037  25000                      RETURN

038  2DC40      update_display: OUTPUT bcd_0, bcd_0_port
039  2DD41                      OUTPUT bcd_1, bcd_1_port
03A  2DE42                      OUTPUT bcd_2, bcd_2_port
03B  2DF43                      OUTPUT bcd_3, bcd_3_port
03C  25000                      RETURN

03D  004F0     shift_bcds_left: LOAD s4, bcd_3
03E  00FE0                      LOAD bcd_3, bcd_2
03F  00ED0                      LOAD bcd_2, bcd_1
040  00DC0                      LOAD bcd_1, bcd_0
041  00C40                      LOAD bcd_0, s4
042  25000                      RETURN

043  004C0    shift_bcds_right: LOAD s4, bcd_0
044  00CD0                      LOAD bcd_0, bcd_1
045  00DE0                      LOAD bcd_1, bcd_2
046  00EF0                      LOAD bcd_2, bcd_3
047  00F40                      LOAD bcd_3, s4
048  25000                      RETURN

049  11C01              incBCD: ADD bcd_0, 01
04A  1DC0A                      COMPARE bcd_0, 0A
04B  3204D                      JUMP Z, inc_overflow
04C  25000                      RETURN
04D  01C00        inc_overflow: LOAD bcd_0, 00
04E  25000                      RETURN

04F  1DC00              decBCD: COMPARE bcd_0, 00
050  32053                      JUMP Z, dec_underflow
051  19C01                      SUB bcd_0, 01
052  25000                      RETURN
053  01C09       dec_underflow: LOAD bcd_0, 09
054  25000                      RETURN

055                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
055                             ; interrupt implementation ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
055                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

055                             ; test which button was pressed and execute the corresponding action
055  09540             isr_imp: INPUT s5, btns_port
056  0D510               testU: TEST s5, btnU
057  3205A                      JUMP Z, testD
058  20049                      CALL incBCD
059  25000                      RETURN
05A  0D504               testD: TEST s5, btnD
05B  3205E                      JUMP Z, testL
05C  2004F                      CALL decBCD
05D  25000                      RETURN
05E  0D502               testL: TEST s5, btnL
05F  32062                      JUMP Z, testR
060  2003D                      CALL shift_bcds_left
061  25000                      RETURN
062  0D508               testR: TEST s5, btnR
063  32066                      JUMP Z, execC
064  20043                      CALL shift_bcds_right
065  25000                      RETURN
066  2002F               execC: CALL transmit_code
067  25000                      RETURN

7F0                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
7F0                             ; interrupt vector is on address 7f0
7F0                             ; we don't have enough room to write a complete isr so we call it
7F0                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
7F0                             ADDRESS 7F0
7F0  20055                 ISR: CALL isr_imp
7F1  20038                      CALL update_display
7F2  29001                      RETURNI enable



All unused memory locations contain zero (equivalent to "LOAD s0, s0")


PSM files that have been assembled
----------------------------------
    /home/b230admin/kcpsm_demo/kcpsm_demo.asm/program.psm


List of defined constants
-------------------------
    CONSTANT name         Value       Source PSM file
 ----------------         -----       ---------------
    BEL                   07
    BS                    08
    CR                    0D
    DCS                   90
    DEL                   7F
    ESC                   1B
    HT                    09
    LF                    0A
    NUL                   00
    ST                    9C
    VT                    0B
    bcd_0_port            40          program.psm
    bcd_1_port            41          program.psm
    bcd_2_port            42          program.psm
    bcd_3_port            43          program.psm
 *  btnC                  00000001'b  program.psm
    btnD                  00000100'b  program.psm
    btnL                  00000010'b  program.psm
    btnR                  00001000'b  program.psm
    btnU                  00010000'b  program.psm
    btns_port             40          program.psm
    buffer_fill_address   20          program.psm
    datestamp_day         09
    datestamp_month       0B
    datestamp_year        16
    timestamp_hours       0F
    timestamp_minutes     21
    timestamp_seconds     0F
    uart_reset_port       1           program.psm
    uart_rx_data_present  00001000'b  program.psm
    uart_rx_port          81          program.psm
    uart_status_port      80          program.psm
    uart_tx_full          00000100'b  program.psm
    uart_tx_port          80          program.psm

       * Unreferenced constant(s)


  No tables defined


List of text strings
--------------------
    STRING name  Value          Source PSM file
 --------------  -----          ---------------
    datestamp$   "09 Nov 2022"
    timestamp$   "15:33:15"


List of line labels
-------------------
    Label             Addr  Source PSM file
 --------             ----  ---------------
 *  ISR               7F0   program.psm
    code_received     00E   program.psm
 *  cold_start        000   program.psm
    decBCD            04F   program.psm
    dec_underflow     053   program.psm
 *  delay_1s          022   program.psm
    delay_loop        025   program.psm
    execC             066   program.psm
    incBCD            049   program.psm
    inc_overflow      04D   program.psm
    isr_imp           055   program.psm
    loop              009   program.psm
    shift_bcds_left   03D   program.psm
    shift_bcds_right  043   program.psm
    testD             05A   program.psm
    testL             05E   program.psm
    testR             062   program.psm
 *  testU             056   program.psm
    transmit_code     02F   program.psm
    uart_read_char    016   program.psm
    uart_write_byte   02A   program.psm
    update_display    038   program.psm
    urc_end           021   program.psm
    urc_no_timeout    017   program.psm

       * Unreferenced label(s)


List of pragma blocks
---------------------
   Name  Addr range  Value
   ----  ----------  -----


Instruction usage statistics
----------------------------
   Instruction  Instances
   -----------  ---------
   ADD          2
   ADDCY        1
   AND          -
   CALL         14
   CALL@        -
   COMPARE      3
   COMPARECY    -
   DISABLE      -
   ENABLE       1
   FETCH        6
   HWBUILD      -
   INPUT        4
   JUMP         13
   JUMP@        -
   LOAD         26
   LOAD&RETURN  -
   OR           -
   OUTPUT       5
   OUTPUTK      1
   REGBANK      -
   RETURN       16
   RETURNI      1
   RL           -
   RR           -
   SL0          -
   SL1          -
   SLA          -
   SLX          -
   SR0          -
   SR1          -
   SRA          -
   SRX          -
   STAR         -
   STORE        4
   SUB          2
   SUBCY        2
   TEST         6
   TESTCY       -
   XOR          -
